[[spi-publishmq]]
= PublishMQ SPI Implementation
:_basedir: ../../../
:_imagesdir: images/


This module (`isis-module-publishmq`) provides an implementation of Apache Isis' link:http://isis.apache.org/guides/rg.html#_rg_services-spi_manpage-PublishingService[`PublishingService`] SPI that submits an XML representation of an link:https://github.com/apache/isis/blob/master/core/schema/src/main/resources/org/apache/isis/schema/ixn/ixn.xsd[`MemberInteractionDto`]s to an link:http://activemq.apache.org[ActiveMQ] queue.

The example app itself also demonstrates how this member interaction event (action invocation or property edit) can be routed using link:http://camel.apache.org[Apache Camel]:

* the payload is enriched using Apache Isis' own link:http://isis.apache.org/guides/ug.html#_ug_restfulobjects-viewer[Restful Objects] viewer (obtaining additional information);

* the enriched message is used to post to a (fake) external SOAP, eg representing a General Ledger.

In addition, the example app configures link:https://jolokia.org/[Jolokia], allowing the ActiveMQ, Camel and other JMX beans to be administered from an external console such as link:http://hawt.io[Hawt.io].

The diagram below shows the moving parts:

image::{_imagesdir}overview.png[width="600px",link="{_imagesdir}overview.png"]


One of the design objectives for the PublishMq module is to allow the ActiveMQ queue (and therefore any Camel routing) to be either embedded (as in the example app) or to be remote.
This is one of the reasons why the payload posted to the queue is the XML representation of a JAXB object (the `InvocationDto`).

To make the example app easier to run, the fake SOAP service representing the external system is actually deployed as a CXF servlet within the example app itself, mounted at `/soap/ExternalSystemAdapter/DemoObject`.
It exposes an API for the Camel routing to post to, and also exposes a query API that simply lists the messages received.
Of course, "in real life" this external system would be running somewhere else on the network (as the diagram shows).




== Application walk-through

[NOTE]
====
The screenshots below *do* demonstrate the functionality of this module, but are out of date in that they are taken from the original isisaddons/incodehq module (prior to being amalgamated into the incode-platform).
====

The following screenshots show how the publishing service publishes the member interaction events that are then routed through to the (fake) external system using Camel.


=== Installing the Fixture Data

First, install sample data:

image::{_imagesdir}010-install-fixtures.png[width="600px",link="{_imagesdir}010-install-fixtures.png"]

This returns the first demo object (an instance of `PublishMqDemoObject`):

image::{_imagesdir}020-update-demo-object.png[width="600px",link="{_imagesdir}020-update-demo-object.png"]


=== Invoke an action

The `updateName()` action is defined as:

[source,java]
----
@Action(
    semantics = SemanticsOf.IDEMPOTENT,
    publishing = Publishing.ENABLED     // <1>
)
public PublishMqDemoObject updateName(
        @ParameterLayout(named="Name") final String name) {
    setName(name);
    return this;
}
----
<1> invocations of this action will be published to the configured implementation of `PublishingService`.


Invoke the action:

image::{_imagesdir}030-update-demo-object.png[width="600px",link="{_imagesdir}030-update-demo-object.png"]


the value of the `name` property should, of course, be updated:

image::images/040-demo-object-updated.png[width=800,height=469,link="https://raw.githubusercontent.com/isisaddons/isis-module-publishmq/master/images/040-demo-object-updated.png"]


=== Camel routing

The example app defines the following Camel route (link:fixture/routing/src/main/resources/camel-config.xml[camel-config.xml]):

[source,xml]
----
<camelContext xmlns="http://camel.apache.org/schema/spring">
  <route id="updateFakeSoapServiceRoute">
    <from uri="activemq-broker:queue:memberInteractionsQueue"/>                 <!-- 1 -->
    <unmarshal>
      <jaxb contextPath="org.apache.isis.schema.ixn.v1" prettyPrint="true"/>    <!-- 2 -->
    </unmarshal>
    <camel:process ref="addExchangeHeaders"/>                                   <!-- 3 -->
    <camel:choice>
      <camel:when>                                                              <!-- 4 -->
        <camel:simple>                                                          <!-- 5 -->
          ${header.ixn[execution$memberIdentifier]} ==
          'org.isisaddons.module.publishmq.fixture.dom.PublishMqDemoObject#updateName()'
        </camel:simple>
        <log message="updateName() received... "/>
        <camel:process ref="attachDomCanonicalDtoUsingRestfulObjects"/>         <!-- 6 -->
        <camel:process ref="postToFakeExternalSoapService"/>                    <!-- 7 -->
        <log message="internalId: ${header.externalSystemInternalId}"/>         <!-- 8 -->
        <camel:to uri="stream:out"/>                                            <!-- 9 -->
      </camel:when>
      <camel:when>
        ...
      </camel:when>
    </camel:choice>
  </route>
</camelContext>
----
<1> subscribe to ActiveMQ for incoming member interaction events (in XML form).
This uses the internal `vm://` protocol for speed
<2> unmarshal to a (JAXB annotated) `InteractionDto` object
<3> using the `AddExchangeHeaders` component provided by this module to add the metadata from the `InteractionDto` to the Camel message.
This allows the message to be routed
<4> use Camel to select which sub-route to following, using...
<5> \... the header attached earlier.
The action identifier header is usually used as the predicate for selecting the sub-route
<6> Use a processor (implemented in the example app) to attach a DTO obtained from a call to Restful Objects.
<7> Use a processor (implemented in the example app) to post a message to the fake external SOAP service.
<8> Log the id allocated by the fake server to the console.
This will increment for each call
<9> Log the message payload to the console.
Note that this does not include any attachments

The referenced beans are defined as:

[source,xml]
----
<bean id="activemq-broker"
      class="org.apache.activemq.camel.component.ActiveMQComponent">
    <property name="brokerURL" value="vm://broker?create=false&amp;waitForStart=5000"/>
</bean>
<bean id="addExchangeHeaders"
      class="org.isisaddons.module.publishmq.dom.camel.AddExchangeHeaders"/>   <!--1-->
<bean id="attachDomCanonicalDtoUsingRestfulObjects"
     class="org.isisaddons.module.publishmq.fixture.routing.AttachDemoObjectDto"
     init-method="init">                                                       <!--2-->
    <property name="base" value="${attachDomCanonicalDto.base}"/>
    <property name="username" value="${attachDomCanonicalDto.username}"/>
    <property name="password" value="${attachDomCanonicalDto.password}"/>
</bean>
<bean id="postToFakeExternalSoapService"
      class="org.isisaddons.module.publishmq.fixture.routing.PostToExternalWebServiceUsingSoap"
      init-method="init">                                                     <!--3-->
    <property name="endpointAddressBase"
              value="${updateExternalSystemAdapter.endpointAddressBase}"/>
    <property name="endpointAddressSuffix"
              value="${updateExternalSystemAdapter.endpointAddressSuffix}"/>
</bean>
----
<1> adds the exchange headers for routing (step 3 in the route, above)
<2> calls Restful Objects to obtain a DTO representing the updated entity (step 6 in the route)
<3> calls fake SOAP service (step 7 in the route)

There are two observable side-effects from the execution of this route.
Firstly, when the fake SOAP service is called, it should return an internal Id.
This, along with the rest of the message payload, are logged to the console:

image::{_imagesdir}050-camel-route-logging.png[width="600px",link="{_imagesdir}050-camel-route-logging.png"]


The screenshot also highlights the two important pieces of information used by the route: the member identifier metadata -- added as a Camel header for routing -- and the target object has was updated.

Second, we can query the fake SOAP service to se the data that was posted to it.
The screenshot below uses link:http://www.soapui.org/[SOAP UI], which can generate stub requests from the fake SOAP service's WSDL (http://localhost:8080/soap/ExternalSystemAdapter/DemoObject?wsdl[http://localhost:8080/soap/ExternalSystemAdapter/DemoObject?wsdl]):

image::{_imagesdir}060-query-fake-server.png[width="600px",link="{_imagesdir}060-query-fake-server.png"]


[WARNING]
====
The above screenshot is out-of-date, showing the format of the `aim.xsd` for 1.12.x, rather than `ixn.xsd` for 1.13.x
====


=== Proxying the REST and SOAP calls

To see in a little more detail what the `attachDtoFromRestfulObjects` and `postToFakeExternalSoapService` processors actually do, we can use the venerable link:http://ws.apache.org/tcpmon/download.cgi[tcpmon] to act as a proxy.
For example, we can set up port 6060 to forward onto port 8080:

image::{_imagesdir}110-proxy-restful-objects.png[width="600px",link="{_imagesdir}110-proxy-restful-objects.png"]


We can similarly do the same for port 7070, also forwarding onto port 8080.

Then, we can reconfigure the app to use these different ports by editing link:webapp/src/main/resources/spring.properties[`spring.properties`]:

[source,ini]
----
attachDomCanonicalDto.base=http://localhost:6060/restful/
updateExternalSystemAdapter.endpointAddressBase=http://localhost:7070/soap/
...
----

When we run once more, we can see that the `attachDtoFromRestfulObjects` processor uses conneg support to obtain a specific canonical DTO that represents the original `PublishedMqDemoObject` entity:

image::{_imagesdir}120-conneg.png[width="600px",link="{_imagesdir}120-conneg.png"]


Using DTOs in this way is important because we want the Camel event bus logic to be decoupled from changes to the internals of the Apache Isis app.
As the screenshot shows, the processor specifies an HTTP Accept header.
The Restful Objects viewer delegates to the configured link:http://isis.apache.org/guides/rg.html#_rg_services-spi_manpage-ContentNegotiationService[`ContentNegotiationService`] SPI, which knows how to map the `PublishedMqDemoObject` entity into the requested `DemObjectDto` DTO:

[source,java]
----
@DomainService(nature = NatureOfService.DOMAIN)
public class PublishMqDemoContentMappingService implements ContentMappingService {
    public Object map(
            final Object object,
            final List<MediaType> acceptableMediaTypes) {
        if(object instanceof PublishMqDemoObject) {
            final PublishMqDemoObject demoObject = (PublishMqDemoObject) object;
            final Bookmark bookmark = bookmarkService.bookmarkFor(object);
            final DemoObjectDto dto = new DemoObjectDto();
            dto.setName(demoObject.getName());
            dto.setDescription(demoObject.getDescription());
            final OidDto oidDto = bookmark.toOidDto();
            dto.setOid(oidDto);
            return dto;
        }
        return null;
    }
    @javax.inject.Inject
    private BookmarkService bookmarkService;
}
----

The call to the fake SOAP service meanwhile is more straightforward: we observe just the regular SOAP messages (the implementation uses `wsdl2java` to create stubs, so the code is very straightforward):

image::{_imagesdir}210-proxy-soapservice.png[width="600px",link="{_imagesdir}210-proxy-soapservice.png"]


=== Jolokia and Hawt.io

As mentioned in the introduction, the example app also configures Jolokia so that consoles such as Hawt.io can be used to monitor/administer internal JMX beans (including ActiveMQ and Camel).

Configuring Jolokia itself turns out to be as simple as updating the classpath and adding its servlet to the `web.xml`:

[source,xml]
----
<servlet>
    <servlet-name>jolokia-agent</servlet-name>
    <servlet-class>org.jolokia.http.AgentServlet</servlet-class>
    <init-param>
        <param-name>discoveryEnabled</param-name>
        <param-value>false</param-value>
    </init-param>
    <init-param>
        <param-name>agentDescription</param-name>
        <param-value>Apache ActiveMQ</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>jolokia-agent</servlet-name>
    <!-- using same convention as standalone ActiveMQ -->
    <url-pattern>/api/jolokia/*</url-pattern>
</servlet-mapping>
----

With this done, we can use Hawt.io to connect to the service:

image::{_imagesdir}310-connect-activemq.png[width="600px",link="{_imagesdir}310-connect-activemq.png"]

Hawt.io itself runs as a separate webapp.
For testing purposes, it can also be run from the command line, eg:

[source,bash]
----
java -jar hawtio-app-1.4.51.jar --port 9090
----


=== Monitoring ActiveMQ and Camel

Once connected we can navigate to the ActiveMQ tab:

image::{_imagesdir}320-monitor-activemq.png[width="600px",link="{_imagesdir}320-monitor-activemq.png"]



and similarly to the Camel tab:

image::{_imagesdir}330-monitor-camel.png[width="600px",link="{_imagesdir}330-monitor-camel.png"]



== How to configure/use

You can either use this module "out-of-the-box", or you can fork this repo and extend to your own requirements.

The module itself consists of submodules:

* `dom-servicespi`, containing the `PublishingService` SPI implementation
* `dom-camel`, that provides utility class to help route messages.
* `dom`, parent module



=== Classpath

Update your classpath:

* by adding importing the parent module's dependency into in your parent module's `pom.xml`: +
+
[source,xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.isisaddons.module.publishmq</groupId>
            <artifactId>isis-module-publishmq-dom</artifactId>
            <version>1.15.0</artifactId>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        ...
    </dependencies>
</dependencyManagement>
----

* by adding the `-dom-servicespi` dependency in your project's `dom` module's `pom.xml`: +
+
[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.isisaddons.module.publishmq</groupId>
        <artifactId>isis-module-publishmq-dom-servicespi</artifactId>
    </dependency>
    ...
</dependencies>
----

* (if you are using Camel for routing and want to use the `AddExchangeHeaders` utility class) by adding (in the appropriate module within your app) the dependency: +
+
[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.isisaddons.module.publishmq</groupId>
        <artifactId>isis-module-publishmq-dom-camel</artifactId>
    </dependency>
    ...
</dependencies>
----

TODO: update these words which xref the example app...  In the example app all the Camel routing can be found in the `-fixture-routing` module.



Check for later releases by searching http://search.maven.org/#search|ga|1|isis-module-publishmq-dom[Maven Central Repo].

For instructions on how to use the latest `-SNAPSHOT`, see the xref:../../../pages/contributors-guide.adoc#[contributors guide].




=== Bootstrapping

In the `AppManifest`, update its `getModules()` method, eg:

[source,xml]
----
    @Override
    public List<Class<?>> getModules() {
        return Arrays.asList(
                ...
                org.isisaddons.module.publishmq.PublishMqModule.class,
                ...
        );
    }
----

You might also need to specify the package for any new services that you have written, eg implementation of `ContentNegotiationService` or similar.


=== Configure ActiveMQ

Configure ActiveMQ so that the publishing service implementation can post to a queue called `memberInteractionsQueue`.

TODO: update these words xref the example app

In the example app this is done using Spring (link:webapp/src/main/resources/activemq-config.xml[activemq-config.xml]):
+
[source,xml]
----
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
  http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd">
    <broker xmlns="http://activemq.apache.org/schema/core"
            brokerName="broker"
            dataDirectory="${activemq.data}"
            useShutdownHook="false"
            useJmx="true"
            >
        ...
        <destinations>
            <queue physicalName="memberInteractionsQueue"/>
        </destinations>
        ...
    </broker>
</beans>
----

This is bootstrapped in the `web.xml`:

[source,xml]
----
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>
        classpath:activemq-config.xml
    </param-value>
</context-param>
----




== Canonical DTOs

TODO: update these words xref the example app

The example app contains a few other little tricks that may be useful if you are looking to deploy a similar architecture for your own application.


=== Generate Canonical DTO referencing Apache Isis' DTOs

As of 1.13.0 Apache Isis includes the link:http://isis.apache.org/schema/ixn/ixn.xsd[`ixn.xsd`] (member interaction) schema (replacing and generalizing the `aim.xsd` provided from 1.9.0 through 1.12.x).
The `PublishingServiceMq` uses this `ixn.xsd` schema (or rather, its Java JAXB equivalent, `InteractionDto`), directly.

The similar `common.xsd` is _also_ used by the demo app in the construction of its own canonical `DemoObjectDto` (use of `OidDto` to represent a bookmark to a published domain object).


=== Centralized Spring configuration

In the example app Spring is used to bootstrap ActiveMQ (link:webapp/src/main/resources/activemq-config.xml[`activemq-config.xml`]), and Camel (link:fixture/routing/src/main/resources/camel-config.xml[`camel-config.xml`]), and also the fake SOAP Subscriber (link:webapp/src/main/resources/externalSystemFakeServer-config.xml[`externalSystemFakeServer-config.xml`]).
The configuration for all is centralized through a propertyPlaceholderConfigurer bean (defined in link:webapp/src/main/resources/propertyPlaceholderConfigurer-config.xml#L23[`propertyPlaceholderConfigurer-config.xml`]).
The location of the property file is specified in the link:webapp/src/main/webapp/WEB-INF/web.xml#L44[`web.xml`]:

[source,xml]
----
<context-param>
    <param-name>spring.config.file</param-name>
    <param-value>classpath:spring.properties</param-value>
</context-param>
----

where link:webapp/src/main/resources/spring.properties[`spring.properties`] is:

[source,ini]
----
activemq.data=activemq-data
enrichWithCanonicalDto.base=http://localhost:8080/restful/
enrichWithCanonicalDto.username=sven
enrichWithCanonicalDto.password=pass
updateExternalSystemAdapter.endpointAddress=http://localhost:8080/soap/ExternalSystemAdapter/DemoObject
----

If necessary the location of this config file can be overridden; see link:http://isis.apache.org/guides/ug.html#_ug_deployment_externalized-configuration[this topic] in the Apache Isis user guide.


=== WSDL to Java

TODO: update link below

Similar to the way in which the .xsd schemas are converted to Java, `wsdl2java` is used to convert the fake server's WSDL to Java stubs.
This WSDL can be found link:externalsystemadapter/wsdl/src/main/resources/org/isisaddons/module/publishmq/externalsystemadapter/wsdl/DemoObject.wsdl[here]; the `pom.xml` configuration can be found link:https://github.com/isisaddons/isis-module-publishmq/blob/master/externalsystemadapter/wsdlgen/pom.xml#L76[here].






== Known issues

None known at this time.




== Dependencies

In addition to Apache Isis, this module also depends upon:

* link:http://activemq.apache.org[ActiveMQ]

* (optional) link:http://camel.apache.org[Camel] +
+
This dependency is considered optional because it merely provides a supporting utility class (`AddExchangeHeaders`).


