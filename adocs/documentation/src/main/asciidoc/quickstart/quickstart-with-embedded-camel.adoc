[[quickstart-with-embedded-camel]]
= Quickstart with Embedded Camel
:_basedir: ../../
:_imagesdir: _images/
:toc:
:generate_pdf:


The application generated by the xref:quickstart.adoc#[quickstart archetype] can be extended to also configure the application to bootstrap a _Spring Framework_ context alongside the Apache Isis framework.
This Spring context hosts an embedded _Apache Camel_ instance, configured to consume from the ActiveMQ message queue published to by the xref:../modules/spi/publishmq/spi-publishmq.adoc#[publishmq] module.



[[__quickstart-with-embedded-camel_project-structure]]
== Project Structure

The diagram below shows how the structure of the application is extended to support this:


image::{_imagesdir}project-structure/module-dependencies/Slide2.PNG[width="800px",link="{_imagesdir}project-structure/module-dependencies/Slide2.PNG"]

where:

* `quickstart-example-embeddedcamel` provides a Spring context file defining a Camel route for consuming published events, as well as supporting Camel bean instances and other classes

* `quickstart-example-canonical` defines a DTO for the `SimpleObject` domain object.

The idea here is that the event published by the xref:../modules/spi/publishmq/spi-publishmq.adoc#[publishmq] module only sends a notification that a significant interaction (action invocation or property edit) has occurred.
It does _not_ attempt to gather together all the information that might be required by downstream consumers interested in this interaction.

Instead, the subscribers (implemented within the Camel route) use the REST API to callback to the originating system, and exploits the link:http://isis.apache.org/guides/rgsvc/rgsvc.html#_rgsvc_presentation-layer-spi_ContentMappingService[ContentMappingService SPI] to obtain DTOs specific to the use case.

The diagram below attempts to explain this:

image::{_imagesdir}embedded-camel/overview.png[width="800px",link="{_imagesdir}embedded-camel/overview.png"]

That is, the `quickstart-exampe-embedded-camel` implements steps 5 through to 11 (step 12 is not implemented at all, just shown as a possible use case).



[[__quickstart-with-embedded-camel_including-the-example-modules]]
== Including the Example Modules


To include the Embedded Camel modules, just uncomment the relevant blocks surrounded by these words:

[source]
----
Comment in to include example modules that set up embedded camel: START
----

to
[source]
----
Comment in to include example modules that set up embedded camel: END
----

You should find there are two such blocks in the various `pom.xml` files, one block in `web.xml`, and one block in the `DomainAppAppManifest.java`.




[[__quickstart-with-embedded-camel_camel-route]]
== Camel Route

To monitor the Camel route, we can use the link:http://hawt.io[hawt.io] console (as also used for monitoring ActiveMQ messages, see the base quickstart's xref:quickstart.adoc#_quickstart_modules_publishing[publshing] support).

Download the hawt.io JAR file and start using:

[source,bash]
----
java -jar hawtio-app-1.5.3.jar --port 9090
----

Then connect to the jolokia servlet (configured in the quickstart's `web.xml`):

image::{_imagesdir}modules/publish/hawtio-jolokia-connect.png[width="600px",link="{_imagesdir}modules/publish/hawtio-jolokia-connect.png"]

with the port set to `8080` and the path set to `/api/jolokia`.

Connecting this time should show a (new) "Camel" tab:

image::{_imagesdir}embedded-camel/hawtio-camel-tab.png[width="600px",link="{_imagesdir}embedded-camel/hawtio-camel-tab.png"]


which also shows a diagram of the route (defined in `example-embeddedcamel-config.xml`):

image::{_imagesdir}embedded-camel/hawtio-camel-route.png[width="600px",link="{_imagesdir}embedded-camel/hawtio-camel-route.png"]


If the `SimpleObject#updateName(...)` action is invoked, then this matches the left hand branch.
The diagram (above) actually indicates this, with each node indicating the number of times it has been traversed.
The "process2" component corresponds to this definition in the route:

[source,xml]
----
<camel:process ref="attachCanonicalDtoUsingRestfulObjects"/>
<log message="DTO: ${header['org.incode.domainapp.example.canonical.SimpleObjectDto']}"/>
----

where `attachCanonicalDtoUsingRestfulObjects` is an alias to this bean:

[source,xml]
----
<bean id="attachCanonicalDtoUsingRestfulObjects"
      class="domainapp.example.embeddedcamel.processor.AttachSimpleObjectDto"
      init-method="init">
    <!-- see propertyPlaceholderConfigurer-config.xml -->
    <property name="base" value="${restful.base}"/>
    <property name="username" value="${restful.username}"/>
    <property name="password" value="${restful.password}"/>
</bean>
----

The `AttachSimpleObjectDto` bean:

* logs using the `StatusMessageClient` utility (provided by the xref:../modules/spi/publishmq[publishmq module]) to log a message using the REST API

* calls the REST API to obtain the DTO for `SimpleObject`

* logs a further message using `StatusMessageClient`

* if successful, attaches the DTO retrieved to the message:

+
[source,java]
----
final SimpleObjectDto entity = response.readEntity(SimpleObjectDto.class);
inMessage.setHeader(SimpleObjectDto.class.getName(), entity);
----

The last statement in the Camel route is:

[source,xml]
----
<log message="DTO: ${header['org.incode.domainapp.example.canonical.SimpleObjectDto']}"/>
----

and thus in the console we see the DTO being logged:

image::{_imagesdir}embedded-camel/ide-console.png[width="600px",link="{_imagesdir}embedded-camel/ide-console.png"]


Back in the Apache Isis application we can use the _Activity_ menu to search for the persisted published event:

image::{_imagesdir}embedded-camel/published-event-1.png[width="600px",link="{_imagesdir}embedded-camel/published-event-1.png"]

This object also has a collection of associated status messages logged by the Camel processor:

image::{_imagesdir}embedded-camel/published-event-2.png[width="600px",link="{_imagesdir}embedded-camel/published-event-2.png"]
